#!/usr/bin/env python# -*- coding: utf-8 -*-#### 导入安装包import pygame, sys, random, gc, os, csv, timefrom pygame.locals import *from math import sin, cos, pi, atan, sqrt, hypotfrom ctypes import windlldef wait4(DURATION, KEYS_ALLOWED = [], ALLOW_QUIT = True ):    """    John Christie's wait4key() function.    KEYS_ALLOWED should be a list, like [K_SPACE, K_l]    ALLOW_QUIT = True, exit when Esc key pressed. """    # set up a few variables    timeOut = False; gotKey = False#;pause=False    startTime = pygame.time.get_ticks()    pygame.event.clear()    while not (timeOut or gotKey ):        # check for time out检查是否超时        current_time = pygame.time.get_ticks()        if current_time >= (DURATION + startTime):            timeOut = True            break        # check for button press检查是否按键        for keyp in pygame.event.get():            if (keyp.type == KEYDOWN):                 # exit pygame if Escape is pressed如果按了esc键退出                if (keyp.key == K_KP_MULTIPLY) and ALLOW_QUIT :                    pygame.quit(); sys.exit();                if keyp.key in KEYS_ALLOWED:                    gotKey   = True                    respKey  = pygame.key.name(keyp.key)                    respTime = current_time                    if gotKey:        key_resp = [True, startTime, respTime, respKey]    else:        key_resp = [False, startTime, None, None]    return key_resp'''def sendTrigger(code):     P = windll.inpout32     P.Out32(0xCEFC, code) # send the event code (could be 1-255)     wait4(20) # wait for 6 ms for BioSemi to receive the code     P.Out32(0xCEFC, 0) # send a code to clear the register     wait4(30)''' # wait for 10 ms"""#### 设置常量white  =(255,255,255)black  =(0,0,0)gray   =(128,128,128)red    =(255,0,0)green  =(0,255,0)scn_size = [1920,1080] ###根据屏幕大小来调整winWidth = 60.0 #cm the width of the monitorviewDist = 60.0 #cm view distancewidthDeg = winWidth/viewDist/pi*180deg2pix  = int(scn_size[0]/widthDeg) # 视角与像素的转化，在标准实验室下，60的视距下，1°视角约等于1cm, 65视距下，1°视角约等于1.1cm，                                   # 70视距下，1°视角约等于1.2cm,做实验前要确认一下分辨率，视距，并且要测量一下刺激大小。fix_loc  = (scn_size[0]/2, scn_size[1]/2)## 刺激的位置Decc = 5  # 半径为 5 visual angletar_locs = []for j in range(4):    sti_x = int(scn_size[0]/2 + sin(j*pi/2)*Decc*deg2pix)    sti_y = int(scn_size[1]/2 + cos(j*pi/2)*Decc*deg2pix)    tar_locs.append((sti_x,sti_y))#### 被试信息def get_subj_info():    """ collect participant information """    subj   = raw_input("Assign a subject ID (experimenter): ")    name   = raw_input("Give two random letters to label the subject: ")    gender = raw_input("Subject's gender is(f/m): ")    age    = raw_input("Subject's age is: ")    runNum   = raw_input("runNumber(1/2/3/4/5/6/7/8/9/10/11/12/13/14/15/16):")    return [subj, name, gender, age, runNum]def init_data_file(SUBJ_INFO):    """ 建立文件夹放被试信息"""     if not os.path.exists('csv_data'): os.mkdir('csv_data')    file_name = 'csv_data/' + SUBJ_INFO[0] + '_' + SUBJ_INFO[1]  + '_' + SUBJ_INFO[4]  + '.csv'    data_file = open(file_name, 'w')    header = ['subj', 'name', 'gender', 'age', 'runNum', 'RT','correct','respkey','shape', 'dist', 'td_dif', 'resp', 'resp_key',             's_tri', 'di_tri', 'td_tri', 're_tri', 'd_loc', 'd_tri', 't_loc', 't_tri','run','startTime','respTime','sTime','eTime','fix_loc', 'prac']    data_file.write('\t'.join(header)+'\n')    return data_file        #### get the trial list and parameter ready hereSUBJ_INFO = get_subj_info() # Get subject info#SUBJ_INFO = ['13','1','1','1','1']run    = SUBJ_INFO[4]Subj_num  = int(SUBJ_INFO[0])## Define the frequencies.f1=[4,4]; f2=[5,6]; f3=[7,7]; f4=[12,13]if Subj_num%4 == 0:    freqs = [f1,f2,f3,f4]    if Subj_num%4 == 1:    freqs = [f2,f3,f4,f1]if Subj_num%4 == 2:    freqs = [f3,f4,f1,f2]if Subj_num%4 == 3:    freqs = [f4,f1,f2,f3]## Define the fixed distractor location and other locations.if Subj_num%2 == 0:    Fixed_dis = 0    Opp_dis   = 2if Subj_num%2 == 1:    Fixed_dis = 2    Opp_dis   = 0Fixed_loc       = tar_locs[Fixed_dis] #高概率干扰位置Other_f_locs    = [l for l in tar_locs if not l in [Fixed_loc]] #剩余的三个位置Distractor_locs = [Fixed_loc]*53 + Other_f_locs*9 #干扰80次，其中53次出现同一位置，剩余3个位置各9次，一共80次random.shuffle(Distractor_locs)Distractor_ran_locs = tar_locs*20#干扰80次，每个位置各20次，一共80次random.shuffle(Distractor_ran_locs)if int(run)<6:    Dist_locs = Distractor_ran_locselse:    Dist_locs = Distractor_locs## 没有干扰的40次T_n_locs = tar_locs * 10random.shuffle(T_n_locs)## Target location for high-prob. distfor i in range(4):    if tar_locs[i] == Fixed_loc:        if i<2:            Off_loc = tar_locs[i+2]        if i>=2:            Off_loc = tar_locs[i-2]      Off_other_locs = [l for l in tar_locs if not l in [Fixed_loc, Off_loc]]T_wf_locs = [Off_loc]*17 + Off_other_locs*18random.shuffle(T_wf_locs)## 实验条件（120个trial，24种条件）Shape      = ['circle', 'diamond']Distractor = ['red', 'green', 'none']TD_dif     = ['same', 'dif']Detection  = ['hori','vert']Shape_t      = [21,22]Distractor_t = [31,32,33]TD_dif_t     = [41,42]Detection_t  = [51,52]## 实验条件cond_list = []for s in Shape:    for ds in Distractor:        for t in TD_dif:            for d in Detection:                if d == 'hori':                    resp_key = 'left'                elif d == 'vert':                    resp_key = 'up'                cond_list.append([s,ds,t,d,resp_key])trig_list = []for s in Shape_t:    for ds in Distractor_t:        for t in TD_dif_t:            for d in Detection_t:                trig_list.append([s,ds,t,d])final_list=[]for i in range(24):    final_list.append(cond_list[i]+trig_list[i])                 trial_list=random.sample(final_list*5,120)# 添加干扰物位置.j = 0for i in range(120):    if trial_list[i][1] == 'none':        trial_list[i] = trial_list[i]+['N_dis']+[10]    else:        trial_list[i] = trial_list[i]+[Dist_locs[j]]                if Dist_locs[j] == tar_locs[Fixed_dis]:            trial_list[i] = trial_list[i]+[11]        if Dist_locs[j] == tar_locs[1]:            trial_list[i] = trial_list[i]+[12]        if Dist_locs[j] == tar_locs[3]:            trial_list[i] = trial_list[i]+[13]        if Dist_locs[j] == tar_locs[Opp_dis]:            trial_list[i] = trial_list[i]+[14]        j = j + 1    # 添加目标位置k = 0l = 0for i in range(120):    if trial_list[i][9] == 'N_dis':        trial_list[i].append(T_n_locs[k])        k = k + 1    else:        if int(run)<6:            T_dis_loc=random.choice([m for m in tar_locs if not m in [trial_list[i][9]]])            trial_list[i].append(T_dis_loc)        else:            if trial_list[i][9] == Fixed_loc:                trial_list[i].append(T_wf_locs[l])                l = l + 1            if trial_list[i][9] in Other_f_locs:                T_wn_loc=random.choice([m for m in tar_locs if not m in [trial_list[i][9]]])                trial_list[i].append(T_wn_loc)    if trial_list[i][11] == tar_locs[Fixed_dis]:        trial_list[i].append(110)    if trial_list[i][11] == tar_locs[1]:        trial_list[i].append(120)    if trial_list[i][11] == tar_locs[3]:        trial_list[i].append(130)    if trial_list[i][11] == tar_locs[Opp_dis]:        trial_list[i].append(140)##初始化pygamepygame.init()pygame.display.set_mode(scn_size,FULLSCREEN|HWSURFACE|DOUBLEBUF) #是否要全屏pygame.mouse.set_visible(False)#隐藏鼠标surf = pygame.display.get_surface()##初始化数据文件DATA_FILE = init_data_file(SUBJ_INFO)##等待的函数 def wait4key(DURATION, KEYS_ALLOWED = [], ALLOW_QUIT = True ):    """    John Christie's wait4key() function.    KEYS_ALLOWED should be a list, like [K_SPACE, K_l]    ALLOW_QUIT = True, exit when Esc key pressed. """    # set up a few variables    timeOut = False; gotKey = False#;pause=False    startTime = pygame.time.get_ticks()    pygame.event.clear()    while not (timeOut or gotKey ):        # check for time out检查是否超时        current_time = pygame.time.get_ticks()        if current_time >= (DURATION + startTime):            timeOut = True            break        # check for button press检查是否按键        for keyp in pygame.event.get():            if (keyp.type == KEYDOWN):                 # exit pygame if Escape is pressed如果按了esc键退出                if (keyp.key == K_KP_MULTIPLY) and ALLOW_QUIT :                    pygame.quit(); sys.exit();                if keyp.key in KEYS_ALLOWED:                    gotKey   = True                    respKey  = pygame.key.name(keyp.key)                    respTime = current_time                    if gotKey:        key_resp = [True, startTime, respTime, respKey]    else:        key_resp = [False, startTime, None, None]    return key_resp#画注视点def sti_fix(fix_loc=fix_loc):    surf = pygame.display.get_surface()    pygame.draw.circle(surf, white, fix_loc, deg2pix/4, 0)#画灰色背景 and 黑色背景def sti_rect_gray1(fix_loc=fix_loc, sti_on = 'yes'):    surf = pygame.display.get_surface()    if sti_on == 'yes':        pygame.draw.rect(surf,gray,((fix_loc[0]-deg2pix),(fix_loc[1]-6*deg2pix),2*deg2pix,2*deg2pix),0)    if sti_on == 'no':        pygame.draw.rect(surf,black,((fix_loc[0]-deg2pix),(fix_loc[1]-6*deg2pix),4*deg2pix,4*deg2pix),0)def sti_rect_gray2(fix_loc=fix_loc, sti_on = 'yes'):    surf = pygame.display.get_surface()    if sti_on == 'yes':        pygame.draw.rect(surf,gray,((fix_loc[0]+4*deg2pix),(fix_loc[1]-deg2pix),2*deg2pix,2*deg2pix),0)    if sti_on == 'no':        pygame.draw.rect(surf,black,((fix_loc[0]+3*deg2pix),(fix_loc[1]-2*deg2pix),4*deg2pix,4*deg2pix),0)def sti_rect_gray3(fix_loc=fix_loc, sti_on = 'yes'):    surf = pygame.display.get_surface()    if sti_on == 'yes':        pygame.draw.rect(surf,gray,((fix_loc[0]-deg2pix),(fix_loc[1]+4*deg2pix),2*deg2pix,2*deg2pix),0)    if sti_on == 'no':        pygame.draw.rect(surf,black,((fix_loc[0]-2*deg2pix),(fix_loc[1]+4*deg2pix),4*deg2pix,4*deg2pix),0)def sti_rect_gray4(fix_loc=fix_loc, sti_on = 'yes'):    surf = pygame.display.get_surface()    if sti_on == 'yes':        pygame.draw.rect(surf,gray,((fix_loc[0]-6*deg2pix),(fix_loc[1]-deg2pix),2*deg2pix,2*deg2pix),0)    if sti_on == 'no':        pygame.draw.rect(surf,black,((fix_loc[0]-7*deg2pix),(fix_loc[1]-3*deg2pix),4*deg2pix,4*deg2pix),0)        #画刺激def sti_circle_diamond(shape='',dist='',td_dif='',resp='',t_loc=[],d_loc=[],nc=[],line_t_locs=[]):    surf = pygame.display.get_surface()    if dist == 'red':        dis_c = red        tar_c = green    if dist == 'green':        dis_c = green        tar_c = red        if shape == 'circle':        if dist == 'none':            for i in tar_locs:                if i == t_loc:                    pygame.draw.circle(surf,nc,i,deg2pix,4)                 else:                    pygame.draw.polygon(surf,nc,((i[0]+deg2pix,i[1]),(i[0],i[1]-deg2pix),(i[0]-deg2pix,i[1]),(i[0],i[1]+deg2pix)),4)        else:                #有干扰时，目标是圆形，干扰物和其余是方形            for i in tar_locs:                if i == t_loc:                    pygame.draw.circle(surf,tar_c,i,deg2pix,4)                elif i == d_loc:                    pygame.draw.polygon(surf,dis_c,((i[0]+deg2pix,i[1]),(i[0],i[1]-deg2pix),(i[0]-deg2pix,i[1]),(i[0],i[1]+deg2pix)),4)                else:                    pygame.draw.polygon(surf,tar_c,((i[0]+deg2pix,i[1]),(i[0],i[1]-deg2pix),(i[0]-deg2pix,i[1]),(i[0],i[1]+deg2pix)),4)                             if shape == 'diamond':   #目标是方形        if dist == 'none':   #没有干扰时，目标是方形，其余是圆形            for i in tar_locs:                if i == t_loc:                    pygame.draw.polygon(surf,nc,((i[0]+deg2pix,i[1]),(i[0],i[1]-deg2pix),(i[0]-deg2pix,i[1]),(i[0],i[1]+deg2pix)),4)                else:                    pygame.draw.circle(surf,nc,i,deg2pix,4)        else:                #有干扰时，目标是方形，干扰物和其余是圆形            for i in tar_locs:                if i == t_loc:                    pygame.draw.polygon(surf,tar_c,((i[0]+deg2pix,i[1]),(i[0],i[1]-deg2pix),(i[0]-deg2pix,i[1]),(i[0],i[1]+deg2pix)),4)                elif i == d_loc:                    pygame.draw.circle(surf,dis_c,i,deg2pix,4)                else:                    pygame.draw.circle(surf,tar_c,i,deg2pix,4)    ## 画线       if dist == 'none':#没有干扰的时候        for i in tar_locs:            if i in line_t_locs:                if resp == 'hori':                     pygame.draw.line(surf,white,(i[0]-int(0.7*deg2pix),i[1]),(i[0]+int(0.7*deg2pix),i[1]),int(0.2*deg2pix))                if resp == 'vert':                     pygame.draw.line(surf,white,(i[0],i[1]-int(0.7*deg2pix)),(i[0],i[1]+int(0.7*deg2pix)),int(0.2*deg2pix))            else:                if resp == 'hori':                     pygame.draw.line(surf,white,(i[0],i[1]-int(0.7*deg2pix)),(i[0],i[1]+int(0.7*deg2pix)),int(0.2*deg2pix))                if resp == 'vert':                     pygame.draw.line(surf,white,(i[0]-int(0.7*deg2pix),i[1]),(i[0]+int(0.7*deg2pix),i[1]),int(0.2*deg2pix))                            if dist != 'none':#有干扰的时候        if resp == 'hori':#如果目标是垂直            if td_dif == 'same':#如果目标和干扰中的线是相同的，都是垂直线                pygame.draw.line(surf,white,(t_loc[0]-int(0.7*deg2pix),t_loc[1]),(t_loc[0]+int(0.7*deg2pix),t_loc[1]),int(0.2*deg2pix))                pygame.draw.line(surf,white,(d_loc[0]-int(0.7*deg2pix),d_loc[1]),(d_loc[0]+int(0.7*deg2pix),d_loc[1]),int(0.2*deg2pix))            if td_dif == 'dif':#如果目标和干扰中的线是不同的，目标垂直，干扰水平                pygame.draw.line(surf,white,(t_loc[0]-int(0.7*deg2pix),t_loc[1]),(t_loc[0]+int(0.7*deg2pix),t_loc[1]),int(0.2*deg2pix))                pygame.draw.line(surf,white,(d_loc[0],d_loc[1]-int(0.7*deg2pix)),(d_loc[0],d_loc[1]+int(0.7*deg2pix)),int(0.2*deg2pix))        if resp == 'vert': #如果目标是水平线            if td_dif == 'same':#如果目标和干扰中的线是相同，都是水平线                pygame.draw.line(surf,white,(t_loc[0],t_loc[1]-int(0.7*deg2pix)),(t_loc[0],t_loc[1]+int(0.7*deg2pix)),int(0.2*deg2pix))                pygame.draw.line(surf,white,(d_loc[0],d_loc[1]-int(0.7*deg2pix)),(d_loc[0],d_loc[1]+int(0.7*deg2pix)),int(0.2*deg2pix))            if td_dif == 'dif':#如果目标和干扰中的线是不同的，目标水平，干扰垂直                pygame.draw.line(surf,white,(t_loc[0],t_loc[1]-int(0.7*deg2pix)),(t_loc[0],t_loc[1]+int(0.7*deg2pix)),int(0.2*deg2pix))                pygame.draw.line(surf,white,(d_loc[0]-int(0.7*deg2pix),d_loc[1]),(d_loc[0]+int(0.7*deg2pix),d_loc[1]),int(0.2*deg2pix))                td_n_locs  = [l for l in tar_locs if l not in [t_loc,d_loc]]#除了目标和干扰物剩余的两个位置        for i in td_n_locs:            if (td_n_locs.index(i)+1)%2==0:                pygame.draw.line(surf,white,(i[0],i[1]-int(0.7*deg2pix)),(i[0],i[1]+int(0.7*deg2pix)),int(0.2*deg2pix))            else:                pygame.draw.line(surf,white,(i[0]-int(0.7*deg2pix),i[1]),(i[0]+int(0.7*deg2pix),i[1]),int(0.2*deg2pix))    #频率条件f_on1 = [];f_off1= []f_on2 = [];f_off2= []f_on3 = [];f_off3= []f_on4 = [];f_off4= []time  = 196for i in range(4):    start_frames = []    frame = freqs[i][0]+freqs[i][1]    frame_num = int(time*1.0/frame+1)        for j in range(frame_num):        start_frames.append(frame*j)        for k in range(time):        if k in start_frames:            on_f =[]            off_f=[]            for a in range(freqs[i][0]):                on_f.append(k+a+1)            for b in range(freqs[i][1]):                off_f.append(k+b+1+freqs[i][0])                                        vars()['f_on'+str(i+1)]=vars()['f_on'+str(i+1)]+on_f            vars()['f_off'+str(i+1)]=vars()['f_off'+str(i+1)]+off_fsti_diamond=range(76,196)#清除屏幕def display_clear():    """ clear up the screen """    surf = pygame.display.get_surface()    surf.fill(black)    pygame.display.flip()    return surfdef put_txt(txt, font_size, loc):    """ Put text on display """    surf = display_clear()    txt_font = pygame.font.Font("simhei.ttf", font_size)    txt_x = loc[0]- txt_font.size(txt)[0]/2    txt_y = loc[1] - txt_font.size(txt)[1]/2    surf.blit(txt_font.render(txt, True, (255,255,255)), (txt_x, txt_y))    pygame.display.flip() def put_txt_test(txt, font_size, loc):    """ Put text on display """    surf = pygame.display.get_surface()    txt_font = pygame.font.Font("simhei.ttf", font_size)    txt_x = loc[0]- txt_font.size(txt)[0]/2    txt_y = loc[1] - txt_font.size(txt)[1]/2    surf.blit(txt_font.render(txt, True, (255,255,255)), (txt_x, txt_y))       #### preparing the instructions for the three tasks ############################def instructions(MODE):    """ Presenting the instructions, I like to use images as instructions because    I have full control of the instruction display"""    if MODE == 'prac':        insImage = pygame.image.load('instruction.png').convert()        surf = display_clear()        surf.blit(insImage, (scn_size[0]/2-insImage.get_width()/2, scn_size[1]/2-insImage.get_height()/2))        pygame.display.flip()    if MODE == 'test':        put_txt(u'请休息片刻后按空格键继续实验!', 24, fix_loc)    wait4key(sys.maxsize, [K_SPACE], True) # wait infinitely    display_clear()#### 错误反应提示#######def error_handle(MODE,fix_loc):      if MODE == 1: error_message =  u"回答错误，请集中注意力!"    if MODE == 2: error_message = u"请尽快回答!"    pygame.mixer.Sound("error.wav").play()    surf = display_clear()    put_txt(error_message, 24, fix_loc)    wait4key(1500)    return True#### 定义一个试次 ######################################################def run_trial(fix_loc,trial_par, subj_info, data_file, prac, run):    """ Run a single trial and record the data.    fix_loc: depending on the experimental condition, could be left or right,     trial_par: trial parameters, such as the presence of target    subj_info: subject information    data_file: opened csv file for saving behavioral data    prac: 'practice' or 'testing'. '"""            shape, dist, td_dif, resp, resp_key, s_tri, di_tri, td_tri, re_tri, d_loc, d_tri, t_loc, t_tri = trial_par    imp_tri = d_tri + t_tri    # present the fixation after interval    sti_fix()    #sendTrigger(s_tri)      #sendTrigger(di_tri)    #sendTrigger(td_tri)    #sendTrigger(re_tri)    wait4key(random.randint(100,300))         nc = random.choice([red,green]) # The color for no distractor condition没有干扰的时候，目标颜色在红/绿中选    tar_n_locs  = [l for l in tar_locs if l not in [t_loc]]    line_t_locs = random.sample(tar_n_locs,1) + [t_loc]    gotKey  = False    timeOut = False    respKey = None    pygame.event.clear()    i = 0    sTime = pygame.time.get_ticks()    #print sTime    respTime = pygame.time.get_ticks()    #sendTrigger(imp_tri)    while i < 196 and not gotKey and not timeOut:        sti_fix()        b = i+1                if b in f_on1:  sti_rect_gray1();pygame.display.flip()                         if b in f_on2:  sti_rect_gray2();pygame.display.flip()                  if b in f_on3:  sti_rect_gray3();pygame.display.flip()        if b in f_on4:  sti_rect_gray4();pygame.display.flip()        if b in f_off1: sti_rect_gray1(fix_loc,'no');pygame.display.flip()            if b in f_off2: sti_rect_gray2(fix_loc,'no');pygame.display.flip()        if b in f_off3: sti_rect_gray3(fix_loc,'no');pygame.display.flip()         if b in f_off4: sti_rect_gray4(fix_loc,'no');pygame.display.flip()        if b == sti_diamond[0]:            startTime = pygame.time.get_ticks()                if b in sti_diamond:            sti_circle_diamond(shape,dist,td_dif,resp,t_loc,d_loc,nc,line_t_locs)            pygame.display.flip()            current_time = pygame.time.get_ticks()            for keyp in pygame.event.get():                if (keyp.type == KEYDOWN):                    gotKey   = True                     if keyp.key in [K_UP,K_LEFT]:                            respKey  = pygame.key.name(keyp.key)                        respTime = current_time                if current_time >= (2000 + startTime):                    error_handle(2,fix_loc)                    timeOut = True                        i = i+1    eTime = pygame.time.get_ticks()    #print eTime    ## Offline    #sendTrigger(0)         if respKey != resp_key and respKey!= None:        sendTrigger(111)        error_handle(1,fix_loc)        RT  = respTime-startTime        cor = 0    if respKey == None:        sendTrigger(222)        error_handle(2,fix_loc)        RT = 'None'        cor = 0    if respKey != None:        RT  = respTime-startTime        cor = 1                # 将数据写入数据文件    trial_data=subj_info+[RT,cor,respKey]+trial_par +[run,startTime,respTime,sTime,eTime,fix_loc,prac]    trial_data = map(str, trial_data) # change all elements to 'string' type    data_file.write('\t'.join(trial_data) + '\n')#### 定义实验 def run_experiment(mode, run='prac'):    if mode == 'practice':        instructions('prac')        #### run the practice trials        t_list = trial_list[0:15]             if mode == 'testing':        instructions('test')        t_list = trial_list[:]        random.shuffle(t_list)     for t in t_list[:]:        run_trial(fix_loc,t, SUBJ_INFO, DATA_FILE,mode,run)        # the ITI is randomized between 500 and 700 ms        display_clear()        restart = suspend(random.randint(500,700))        #sendTrigger(restart)#暂停的函数def suspend(DURATION):    pygame.display.flip()    restart = 249    sus =wait4key(DURATION, [K_h], True)    if sus[3] == 'h':        put_txt(u'实验已经暂停，请稍微休息会', 24, fix_loc)        wait4key(sys.maxsize, [K_p], True)        put_txt(u'实验重新开始', 24, fix_loc)        wait4key(1000)        display_clear()        restart = 250    return restart##### 开始实验#run输入1,10个练习后，4个block基线条件，8个block学习条件if run == '1':    run_experiment('practice',run)    run_experiment('testing',run)    #### end experiment, display a message and do the clean-upif run == '15':    put_txt(u"谢谢参与，这里有两个问题需要您作答,请按空格键继续", 24, (scn_size[0]/2, scn_size[1]/2))    wait4key(sys.maxint, [K_SPACE], True) # wait infinitely    surf=display_clear()    loc_num = ['1','2','3','4']    for i in tar_locs:        pygame.draw.circle(surf,gray,i,deg2pix,3)        put_txt_test(loc_num[tar_locs.index(i)], 24, i)    put_txt_test(u"请回答你是否注意到干扰刺激总是出现在某个位置. 请按1-4数字键选择相应位置!", 24, (scn_size[0]/2, scn_size[1]/2-6*deg2pix))    pygame.display.flip()    CRESP = wait4key(sys.maxint,[K_1,K_2,K_3,K_4],True)    display_clear()    put_txt_test(u"请回答你有多大的把握你刚刚的答案是正确的，请按1-7数字键反应!", 24, (scn_size[0]/2, scn_size[1]/2-2*deg2pix))    put_txt_test(u"1,非常确定；2，较确定；3，确定，4，无法判断；5，不确定；6，较不确定；7；非常不确定", 24, (scn_size[0]/2, scn_size[1]/2+2*deg2pix))    pygame.display.flip()    CCRESP = wait4key(sys.maxint,[K_1,K_2,K_3,K_4,K_5,K_6,K_7],True)    display_clear()    c_data = map(str, ['conf'] + SUBJ_INFO + CRESP + CCRESP)    DATA_FILE.write('\t'.join(c_data) + '\n')put_txt(u"实验结束，谢谢你的参与!", 24, (scn_size[0]/2, scn_size[1]/2))wait4key(2000)# Close the DATA fileDATA_FILE.close()#Close the experiment graphicspygame.display.quit()pygame.quit()